## Запуск программы:
1. "make run" или "go run cmd/main.go"
2.  Ссылка для тестирования функционала в коллекции **POSTMAN:**  https://go.postman.co/workspace/Team-Workspace~d861f7b1-f86b-41dc-8392-4f629e35c170/collection/20613327-bc1c9597-c36b-491c-b955-416d6f8695ed?action=share&creator=20613327
3. В **POSTMAN** коллекции `e-commerce-task` указаны API и методы которые обрабатывает данная программа
4. Данная программа работает на `localhost:9000`

## e-commerce-task

## Задание
Написать обычный CRUD-сайт, в котором можно добавлять, редактировать и удалять записи (например, товары). 
Необычно в этом задании то, что:
1. В качестве базы данных будет использоваться хранилище ключ-значение (embedded key-value store) - **Boltdb**.
Официальное описание с API по Boltdb лежит здесь в Readme: https://github.com/boltdb/bolt
2. В качестве сериализатора данных для BoltDb будет использоваться `encoding/gob`, вместо привычного `encoding/json`: https://pkg.go.dev/encoding/gob

Это задание заодно будет проверкой того, насколько легко вы осваиваете новые технологии и умеете читать документацию.

## Модель и хранение данных
Модель товара:
```
type Product struct {
	Id    int
	Name  string
	Price int
}
```
Валидация: `Name` обязателен для заполнения и должен быть уникальным, а `Price` должен быть положительным (> 0).

BoltDb работает только с `[]byte`, поэтому все данные надо сериализовать/десериализовать с помощью `encoding/gob` в байты.
Т.е схема для записи в базу будет: `Product -> encoding/gob -> []byte -> boltdb`
А для чтения наоборот: `boltdb -> []byte -> encoding/gob -> Product`.

Нужно создать одну коллекцию (в терминологии boltdb используется `bucket`) для самих товаров, где **key - Id, value - Product**.

И бакет для индекса по названию товара (Name), где **key - Name, value - Id**. Индекс нужен будет для поиска товара по названию.

## Веб-сервер
После того, как разберетесь с хранением данных, нужно создать обычный веб-сервер со страницами для CRUD. API больше похож на RPC, а не REST. Будут следующие эндпойнты:
### Эндпойнты для веб-страниц:
- **`/products`**
  
  Открывается страница для просмотра всех существующих товаров. Внешний вид, css стили не важны, можно использовать голый html. 
  Содержимое страницы:
  - таблица со строками, где каждая строка это товар
  - одна кнопка "создать товар", которая перемещает на `/product/add` 
  - кнопка "редактировать" на каждой строке товара, которая перемещает на `/product/edit/{productId}`, где `productId` - id товара
  - кнопка "удалить" на каждой строке товара, которая вызывает команду на удаление `/cmd/delete-product`. После удаления, страница обновляется
  - инпут для поиска товара по названию и кнопка "Поиск". При нажатии на кнопку, посылается запрос на сервер на `/q/product-search-by-name` для поиска товара по названию, и выдается тот товар, у которого название совпало с поиском (в реальном проекте, конечно, поиск делают по подстроке и выдают список товаров, но для нашего тестового задания этого достаточно).
- **`/product/add`**

  Открывается страница для добавления нового товара.
  Содержимое страницы:
  - форма для заполнения полей по новому товару
  - кнопка "Создать", которая отправляет данные на `/cmd/add-product`. После успешного создания, открывается страница `/products`.
  - кнопка "Отмена", которая открывает предыдущую страницу `/products`
  - текстовое поле для ошибок валидации, которые пришли с сервера: если неправильно заполнили поля и т.д.
- **`/product/edit/{productId}`**

  Открывается страница для редактирования существующего товара. Товар берется из базы по переданному `{productId}` в URL.
  Содержимое страницы:
  - форма с заполненными полями по товару
  - кнопка "Сохранить", которая отправляет данные на `/cmd/edit-product`. После успешного редактирования, открывается страница `/products`.
  - кнопка "Отмена", которая открывает предыдущую страницу `/products`.
  - текстовое поле для ошибок валидации, которые пришли с сервера: если неправильно заполнили поля и т.д.
### Эндпойнты для запросов:
- **`/q/product-search-by-name`**

  Принимает json:
  ```
  {
  	"searchName": ""
  }
  ```
  Выдает json:
  ```
  {
  	"product": {...} // товар, у которого название совпало с searchName
  }
  ```
### Эндпойнты для команд:
- **`/cmd/add-product`**

  Принимает json (поля заполнены для примера):
  ```
  {
  	"name": "new product", 
  	"price": "1599"
  }
  ```
  Выдает json, для успешного результата:
  ```
  {
  	"status": "success",
  	"productId": 123 // id последнего созданного товара
  }
  ```
  Выдает json, для провального результата:
  ```
  {
  	"status": "failure",
  	"error":  "Price must be positive number" // ошибка валидации
  }
  ```
- **`/cmd/edit-product`**

  Принимает json (поля заполнены для примера):
  ```
  {
  	"id": 123,
  	"name": "changed name",
  	"price": "2599"
  }
  ```
  Выдает json, для успешного результата:
  ```
  {
  	"status": "success"
  }
  ```
  Выдает json, для провального результата:
  ```
  {
  	"status": "failure",
  	"error":  "Price must be positive number" // ошибка валидации
  }
  ```
- **`/cmd/delete-product`**

  Принимает json (поля заполнены для примера):
  ```
  {
  	"id": 123
  }
  ```
  Выдает json, для успешного результата:
  ```
  {
  	"status": "success"
  }
  ```
  Выдает json, для провального результата:
  ```
  {
  	"status": "failure",
  	"error":  "Error occured" // например серверная ошибка
  }
  ```
